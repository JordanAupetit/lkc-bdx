\documentclass[17pts]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{xcolor}
\usepackage[hyphens]{url}
\usepackage[hidelinks]{hyperref}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{geometry}
\usepackage{textcomp}
\usepackage{tabularx}
\usepackage{wrapfig}
\usepackage{lscape}
\usepackage{rotating}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{titlesec}

\usepackage{pdfpages}

\setcounter{secnumdepth}{4}
\titleformat{\paragraph} {\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph} {0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\renewcommand*\rmdefault{ppl}
\hypersetup{hypertexnames=true}
\geometry{hmargin=2.5cm,vmargin=1.5cm}
\usepackage{float} %Option H pour les figures, utile.

\usepackage{fancyhdr}
\pagestyle{fancy}
\usepackage{lastpage}

\fancypagestyle{IHA-fancy-style}{%
  \fancyhf{}% Clear header and footer
  \fancyhead[L]{Université de Bordeaux\\
  Projet de programmation : Aide à la compilation de noyaux Linux}
  \fancyhead[CR]{}
  \fancyfoot[C]{\thepage/\pageref{LastPage}
   }% Custom footer
  \renewcommand{\headrulewidth}{1pt}
  \renewcommand{\footrulewidth}{0pt}
}

% Redefine the plain page style
\fancypagestyle{plain}{%
  \fancyhf{}%
  \renewcommand{\headrulewidth}{0pt}
  \renewcommand{\footrulewidth}{0pt}
}

\title{Rapport du projet de PDP \\ Aide à la compilation de noyaux Linux}
\author{Aupetit Jordan, Berarde Fabien, Lemasson Mickael, Thiao-Layel Bruno \\
        Chargé de TD : Blanc Xavier\\
        Client : De Rochefort Xavier}

\begin{document}
\maketitle
%\clearpage
\newpage
\pagestyle{empty}
\chapter*{Remerciements}

Nous tenons à remercier toutes les personnes qui ont aidé au cours de notre
projet et plus particulièrement :\\

\begin{itemize}
  \item Xavier Blanc, notre chargé de TD, pour sa disponibilité et ses conseils
      prodigués tout au long de notre projet, autant sur la phase d'analyse que
      sur la phase de développement.
  \item Xavier de Rochefort et Alan Charpentier, pour avoir toujours été
      disponible et avoir répondu à toutes nos questions concernant leurs
      attentes.
  \item Philippe Narbel, notre professeur de Projet de Programmation (PdP), pour tous
      les conseils qu'il nous a donnés concernant la gestion de projet, la
      formalisation et la structuration du code.
  \item Le jury, pour le temps qu'il accordera à la lecture de notre mémoire.
\end{itemize}

\tableofcontents
\clearpage
\listoffigures
\clearpage

\pagestyle{IHA-fancy-style}

Dans le cadre de notre projet de programmation de première année de Master,
nous avons choisi le sujet « Aide à la compilation de noyaux Linux ».  \\

Ce sujet consiste à créer un outil permettant de configurer un noyau répondant
uniquement aux besoins de l'utilisateur. Il est déjà possible de configurer
soi-même un noyau, mais la tâche peut être très fastidieuse à cause du manque
de simplicité des solutions proposées. La plus-value que nous allons apporter
sera de permettre à un utilisateur non expert de configurer simplement son
noyau en l'allégeant à sa guise.  \\

Dans ce mémoire, nous présentons, dans un premier temps, les objectifs de notre
projet, puis nous expliquons l’organisation aussi bien au niveau technique que
fonctionnel de notre groupe. Ensuite nous analysons l'existant de ce projet.
\\

Puis, nous développons les aspects relatifs à l’analyse avec la définition des
différents besoins du client et à la conception ainsi que la réalisation de
notre projet et les tests réalisés.  \\

Enfin nous présentons les résultats obtenus ainsi que les perspectives, tant
fonctionnelles que techniques.
\clearpage

\chapter{Présentation du projet}\thispagestyle{IHA-fancy-style}
\label{cha:Présentation du projet}
Notre sujet « Aide à la compilation de noyaux Linux » a pour principal objectif
la conception d'un logiciel. Celui-ci doit permettre la configuration un noyau
pour que l'utilisateur puisse avoir seulement les options qu'il souhaite.  Le
fichier de configuration d'un noyau Linux est composé d'options qui permettront
lors de la compilation d'activer des services à la demande.  Certaines options
requièrent ou excluent la présence d'autres options.  \\

Notre objectif premier est de créer un outil avec une interface simple et
accessible par un grand nombre d'utilisateurs. Nous ne devons pas perdre de vue
que la configuration d'un noyau est une tâche très longue et sujette aux
erreurs. De ce fait, une bonne ergonomie permettra de simplifier ce processus.
Nous devons également reprendre les fonctionnalités de base en permettant à
l'utilisateur de générer une configuration par défaut en fonction de
l'architecture qu'il choisit. Il doit pouvoir modifier les valeurs des options
qui ne sont pas en conflit et générer un fichier en fonction de ses choix.  \\

De plus, nous avons pour objectif de rajouter des fonctionnalités présentes
dans certaines des solutions existantes ou qui n'existent simplement pas.  Nous
avons dû permettre de faire une recherche d'options, non seulement sur son nom,
mais également sur sa description et son message d'aide.  \\

Ensuite, l'outil doit faciliter la résolution des conflits lorsque la valeur
d'une option n'est pas modifiable. En effet, il est possible qu'on ne puisse
pas activer une option, car celle-ci, par exemple, ne doit pas être activée en
même temps qu'une autre option. Nous affichons à l'utilisateur la liste des
options en conflit avec celle qu'il souhaite activer pour qu'il puisse y
accéder rapidement.  \\

Enfin, en partant de l'idée de proposer une configuration par défaut en
fonction de son matériel, nous avons développé un site communautaire.  Celui-ci
est une base permettant d'ajouter, de modifier ou de supprimer des relations
entre un matériel et des options. Il sera alors possible de consulter cette
base afin de pouvoir trouver celles qui lui correspondent.\\
Celui-ci peut être retrouvé au lien suivant :
\textit{jordan.aupetit.emi.u-bordeaux.fr/PDP}

\chapter{Organisation de l'équipe}\thispagestyle{IHA-fancy-style}
\label{cha:Organisation de l'équipe}
    \section{Fonctionnement de l'équipe}
    \label{sec:Fonctionnement de l'équipe}

Nous avions décidé assez rapidement en début d'année de Master de former notre
groupe pour le projet de programmation. Lors du choix des sujets, nous avons
pris en compte les préférences de chacun et nous avons ainsi pu choisir ce
sujet. Celui-ci nous a tout de suite intéressés puisque c'est avant tout un
projet concret qui vise à répondre à un réel besoin.  En ce qui concerne la
mise en place des bases de notre travail en équipe, nous avons réussi à nous
organiser rapidement.  \\

Dès le début, nous avons commencé à répartir nos tâches, ce qui nous a permis
d’avancer plus rapidement que ce soit dans l’analyse ou, plus tard, dans le
développement. Il était très important pour nous de bien les séparer, car malgré
un échange d’informations constant avec des outils tels que Git ou Google
Drive, il était parfois difficile de travailler à plusieurs sur une même tâche
sans se gêner mutuellement. Les sessions de travail individuelles étaient
souvent suivies de réunions, afin de rassembler les travaux de chacun.  \\

\section{Gestion du projet}
\label{sec:Gestion du projet}
Au début du projet, nous avions établi un planning prévisionnel non schématisé
des tâches à réaliser. Cependant, celui-ci a fait l'objet de diverses
modifications en raison des différents aléas rencontrés.

\begin{sidewaysfigure}
    \includegraphics[scale=0.5]{./illustrations/planning_initial_pdp.png}
    \centering
    \caption{Planning initial du projet}
    \label{fig:PlanningInitial}
    \vspace{10.00mm}
    \includegraphics[scale=0.5]{./illustrations/planning_final_pdp.png}
    \centering
    \caption{Planning final du projet}
    \label{fig:PlanningFinal}
\end{sidewaysfigure}

\newpage
\chapter*{Commentaires critiques}\thispagestyle{IHA-fancy-style}

Voici le planning prévisionnel de la réalisation de nos tâches durant notre
projet ainsi que le planning final.  \\

On peut constater que chaque tâche ne s'est pas déroulée comme prévu.  En
effet, notre projet a nécessité une grande phase de recherche sur le problème
de résolution des conflits, de détection du matériel et la réalisation des
différents tests qui a duré plus longtemps.  La réalisation de l'ébauche de la
bibliographie et de l'existant nous a pris une semaine supplémentaire suite aux
retours que nous avons eus. Enfin, le codage de l'application et les tests se
sont terminés avec un peu plus d'une semaine de retard par rapport à la date
que nous avons prévu.  \\

Ensuite, durant la phase de conception, nous avons pu modifier certaines
tâches. En effet, la résolution des conflits a été écartée pour simplement
aider l'utilisateur à trouver les options qui posent problème et en le laissant
les corriger seul. L'idée de détecter automatiquement le matériel de
l'utilisateur pour lui proposer une configuration a été abandonnée au profit
d'un site communautaire contenant des relations entre des options et du
matériel.

\section{Logiciels et technologies utilisés}
\label{sec:Logiciels et technologies utilisés}
\begin{figure}[H]
    \centering
    \begin{subfigure}{.2\linewidth}
    	\includegraphics[scale=0.3]{illustrations/git.png}
    \end{subfigure}
    \hskip2em
    \begin{subfigure}{.2\linewidth}
    	\includegraphics[scale=0.15]{illustrations/github.png}
    \end{subfigure}
\end{figure}

Git est un logiciel de gestion de versions.  C'est un logiciel libre créé par
Linus Torvalds.  Git fonctionne de façon décentralisée, mais nous utilisons les
serveurs de Github pour gérer notre dépôt.  Nous avons utilisé ce logiciel afin
de faciliter le travail collaboratif. \\

\begin{figure}[H]
    \includegraphics[scale=0.15]{illustrations/GoogleDrive.png}
    \centering
\end{figure}

Google drive est un service de stockage et de partage de fichiers dans le
Cloud. Nous l'avons utilisé afin de pouvoir partager et éditer des documents de
manière simultanée.\\

\begin{figure}[H]
    \includegraphics[scale=0.15]{illustrations/lucidchart.png}
    \centering
\end{figure}

LucidChart est un service qui permet de travailler collaborativement à la
réalisation de différents diagrammes. Nous nous sommes servis de celui-ci afin
de réaliser tous les schémas relatifs à notre analyse.\\

\begin{figure}[H]
    \includegraphics[scale=1.1]{illustrations/texmaker.png}
    \centering
\end{figure}

Texmaker est un logiciel libre destiné à l'édition de documents LaTeX.
Il est possible de visionner le rendu de notre texte directement dans celui-ci.
Nous l'avons utilisé afin de compiler nos fichiers LaTeX en PDF.\\

\begin{figure}[H]
    \includegraphics[scale=0.2]{illustrations/python.png}
    \centering
\end{figure}

Python est un langage de programmation objet multiplateforme.  Il favorise la
programmation impérative structurée et orientée objet. Il est doté d'un typage
dynamique fort, d'une gestion automatique de la mémoire par ramasse-miettes. Il
est similaire au Perl, Ruby et Smalltalk.  Nous avons décidé d'utiliser ce
langage, dans sa version 2.7, dans un premier temps pour faciliter
l'utilisation d'une bibliothèque python que nous avons trouvé, mais également
pour simplifier la portabilité de l'application finale.\\

\begin{figure}[H]
    \includegraphics[scale=0.2]{illustrations/gtk.png}
    \centering
\end{figure}

GTK+ est un ensemble de bibliothèques logicielles, c'est-à-dire un
ensemble de fonctions permettant de réaliser des interfaces graphiques.  Nous
avons eu le choix entre GTK et QT pour l'interface graphique de notre
application, et nous avons choisi GTK, principalement car certains d'entre nous
l'avaient déjà utilisé auparavant. D'un point de vue fonctionnel, les deux
bibliothèques sont tout aussi performantes dans la plupart des cas. Nous
utilisons cette bibliothèque dans sa version 3.8.5.\\

\begin{figure}[H]
    \includegraphics[scale=0.3]{illustrations/html-css-js-php-mysql.png}
    \centering
\end{figure}

PHP, MySQL, HTML5, CSS3 et Javascript. Nous avons utilisé ces différents
langages afin de créer le site de notre projet. Le couple PHP et MySQL a
permis de faire la liaison entre le site et la base de données. Les langages
HTML5 et CSS3 permettent de gérer le contenu et son agencement.  Enfin, le
Javascript a permis de gérer les différents évènements sur la page à l'aide du
Framework JQuery dans sa version 2.1.0. Nous avons également utilisé le
Framework Bootstrap dans sa version 3.1.1 afin d'avoir un design simple et
rapide à mettre en place pour le site.

\chapter{Étude de l'existant}\thispagestyle{IHA-fancy-style}
\label{cha:Étude de l'existant}
\section{Configuration des options du noyau}
\label{sec:Configuration des options du noyau}
La principale tâche à effectuer avant de lancer la compilation du noyau est de
créer un fichier \textit{.config} comportant toutes les options disponibles
pour le noyau.  Après avoir récupéré le noyau (sur \textit{Kernel.org}),
l'utilisateur peut constater qu’il n’y a pas de fichier \textit{.config} par
défaut.  Il faut donc le générer et plusieurs options s’offrent à lui : \\

Récupérer, sur l'ordinateur, le fichier \textit{.config} d’un noyau qu'il
souhaite modifier. Cependant, il risque d’y avoir des incompatibilités à cause
de la version des noyaux.

\begin{description}
    \item[make oldconfig :] Qui permet de récupérer la configuration du noyau
        qui s'exécute sur la machine, et sélectionne automatiquement les
        options compatibles avec le noyau à configurer.  En cas d'options
        litigieuses, l'avis de l'utilisateur est requis.
    \item[make defconfig :] Qui permet de générer un fichier de configuration
        générique. C’est la meilleure option permettant d’optimiser son noyau
        sans repartir de zéro. Malgré tout, il crée une configuration
        \textit{minimale} générique et non spécifique à la machine de
        l’utilisateur.  Le fichier peut donc être optimisé.
\end{description}

Après avoir généré une configuration initiale, il est possible d’utiliser
différents outils pour la modifier tels que :

\begin{description}
\item[make config :]              Un programme en ligne de commande \\
        \begin{figure}[H]
            \includegraphics[scale=0.7]{illustrations/configLine.png}
            \centering
            \caption{Interface en ligne de commande}
            \label{fig:MakeConfig}
        \end{figure}
        \pagebreak
    \item[make menuconfig :]      Un programme utilisant ncurse \\
        \begin{figure}[H]
            \includegraphics[scale=0.7]{illustrations/menuconfig.png}
            \centering
            \caption{Interface utilisant Ncurse}
            \label{fig:MakeMenuConfig}
        \end{figure}
\item[make xconfig :]             Un programme utilisant QT \\
        \begin{figure}[H]
            \includegraphics[scale=0.4]{illustrations/xconfig.png}
            \centering
            \caption{Interface utilisant QT}
            \label{fig:MakeXconfig}
        \end{figure}
        \pagebreak
\item[make gconfig :]             Un programme utilisant GTK \\
        \begin{figure}[H]
            \includegraphics[scale=0.9]{illustrations/gconfig.jpg}
            \centering
            \caption{Interface utilisant GTK}
            \label{fig:MakeGconfig}
        \end{figure}
    \item[eCos :] Un programme qui permet de configurer les noyaux pour le système
        d’exploitation eCos. C’est une autre source d’information
        sur laquelle se baser. \\
        \begin{figure}[H]
            \includegraphics[scale=1.2]{illustrations/eCos_config.png}
            \centering
            \caption{Interface de configuration de noyau pour l'OS eCos}
            \label{fig:InterfaceEcos}
        \end{figure}
        \pagebreak
    \item[kcheck (kernel check) :]Un programme qui permet également de configurer les options
        d’un noyau à compiler. \\
        Il propose deux modes :
    \begin{description}
        \item[Automatique :] kcheck va tenter de déterminer les options du noyau
            en fonction de la machine sur laquelle il est lancé.
        \item[Manuel :] kcheck permet à l’utilisateur de modifier comme bon lui
            semble les différentes options du fichier de configuration du noyau.
    \end{description}
        \begin{figure}[H]
            \includegraphics[scale=0.8]{illustrations/kernel_check.png}
            \centering
            \caption{Interface de configuration d'un noyau proposant la détection du matériel pour les noyaux 2.*}
            \label{fig:KernelCheck}
        \end{figure}
\end{description}

Une étude a été réalisée par Kacper Bak et Karim Ali de l’université Waterloo
afin d’améliorer la convivialité de la configuration d’un noyau Linux
\cite{Waterloo:Etude}.  \\

Celle-ci a permis de mieux cerner les besoins des utilisateurs en observant
leurs difficultés à utiliser les outils existants. Ils ont réalisé un prototype
qu’ils ont fait tester et qu’ils ont amélioré afin d’obtenir le squelette d’un
outil facilitant la configuration d’un noyau Linux. \\ \\

\begin{figure}[H]
    \includegraphics[scale=0.6]{illustrations/lkc_config.png}
    \centering
    \caption{Prototype de l'université de Waterloo}
    \label{fig:PrototypeWaterloo}
\end{figure}

Leur projet a donc abouti sur un prototype non fonctionnel.  L’ergonomie de
leur application sera une grande source d’inspiration pour nous grâce aux avis
qu’ils ont récoltés auprès d’utilisateurs.  \\

Les quatre premiers outils présentés (\textit{config, menuconfig, xconfig} et
\textit{gconfig}) sont les plus couramment utilisés pour configurer un noyau
Linux avant sa compilation.  Nous sommes arrivés à cette conclusion, car dans
un premier temps, ces outils sont présents au sein même des sources du noyau
Linux.  Et dans un second temps, en recherchant comment d'autres personnes
réalisaient cette configuration, nous avons constaté qu'ils utilisaient à
chaque fois l'un de ces outils et principalement ceux avec une interface
graphique.  \\

Pour ce qui est des deux derniers outils (\textit{eCos} et \textit{kCheck}),
ils sont beaucoup moins répandus, mais ils répondent à différents besoins de
notre projet dont nous allons nous inspirer :
\begin{itemize}
    \item La gestion des conflits entre les options
    \item La détection du matériel pour générer le fichier de configuration\\
\end{itemize}

Enfin, le dernier outil est un prototype réalisé par l'université de Waterloo,
qui constitue notre plus importante base pour ce projet. En effet, celui-ci
ayant été réalisé après une étude des besoins des utilisateurs, il comporte des
informations précieuses pour réaliser notre PdP.  \\

\pagebreak

\section{Difficultés de la configuration}
\label{sec:Difficultés de la configuration}
Il existe plusieurs raisons qui font que la configuration des options d’un
noyau est une tâche fastidieuse et difficile : \\

Tout d’abord, le principal problème se situe au niveau des conflits et des
dépendances entre les options. En effet, celles-ci peuvent être liées à
d’autres options ou être exclusives, c’est-à-dire que si une option est
sélectionnée, implique qu'une autre peut ne plus l’être.  Le problème de
certains des outils actuels est que les options en conflit avec ne sont plus
visibles. Donc, lorsque l’on cherche une option précise qui n’est plus affichée
et que l’on ne sait pas quelles sont celles en conflit avec elle, il est très
difficile de corriger cette erreur.  \\

En outre, lorsqu'une option est sélectionnée, les outils actuels désactivent
automatiquement et sans prévenir l'utilisateur celles qui sont en conflit ou
celles qui en dépendent.  \\

Enfin, il est compliqué pour un utilisateur non expert de trouver une option
précise sans la connaître parfaitement. Le nom de cette option ne représente
pas toujours très bien sa fonction, ce qui fait que la recherche des options
dans l’outil n’est pas aisée.  On constate qu’il y a une aide pour chacune des
options et il est dommage que la recherche par mots-clés ne s’effectue pas
également dans leur aide associée.

\section{Recherches bibliographiques}
\label{sec:Recherches bibliographiques}
Notre sujet se repose sur un projet existant. En effet, l'université de
Waterloo a réalisé une étude approfondit \cite{Waterloo:Etude} sur la facilité
d'utilisation des outils de configuration du noyau Linux. On y trouve les
résultats de leurs tests auprès de différents utilisateurs, ce qui nous permet
d'avoir des informations sur les besoins réels vis-à-vis de cet outil. L'équipe
a réalisé un prototype qui prend en compte ces modifications, et qui peut
être accessible depuis leur dépôt Github \cite{Waterloo:Github}.  \\

Nous avons trouvé d'autres avis d'utilisateurs au sein d'une étude
\cite{Hubaux:2012:USC:2110147.2110164}. On peut y observer les principaux
problèmes qu'ils ont rencontrés. Par exemple, on peut constater que la gestion
des conflits est une fonctionnalité qui pose généralement des difficultés.  \\

Pour mieux comprendre notre sujet, nous avons configuré et compilé un noyau
Linux que nous avons téléchargé sur le site officiel \cite{Kernel}. On peut
trouver au sein du dossier téléchargé, différents outils permettant de réaliser
la configuration du noyau avant sa compilation. On y trouve \textit{menuconfig,
xconfig} et \textit{gconfig} qui sont des outils graphiques plus simples
d'utilisation que l'outil en ligne de commande \textit{config}.  \\

La configuration étant difficile, nous avons trouvé sur le forum de Linux
\cite{Existant:Kernel:ForumTutoConfig} des explications très détaillées. Ce
guide reprend \textit{pas à pas} chacune des options et les détaille une à une
afin de mieux comprendre celles qui peuvent être activées ou non.  \\

Une fonctionnalité qui pourrait être utile pour un utilisateur serait de
pouvoir détecter le matériel de son ordinateur (ou une partie) afin de pouvoir
générer partiellement le fichier de configuration correspondant à sa machine.
Nous avons trouvé un tutoriel \cite{Existant:Kernel:outils} traitant de la
compilation du noyau Linux et qui évoque ce point particulier.  \\

Un des problèmes évoqués par les testeurs de l'étude \cite{Waterloo:Etude} de
l'université de Waterloo, est que le système de gestion des conflits des outils
actuels n'est pas pratique, car aucune indication n'est donnée lorsqu'une
option est sélectionnée. Nous avons trouvé un outil qui effectue ce traitement
des conflits, mais pour un système d'exploitation différent : eCos
\cite{Existant:EcosConfig}. En nous en inspirant, nous pourrons éventuellement
proposer un mécanisme similaire dans notre outil de configuration.  \\

L'étude \cite{Waterloo:Etude} explique brièvement comment fonctionne
l'arborescence des modules au sein du noyau Linux. Nous avons donc décidé
d'approfondir ce point et nous avons trouvé un fichier
\cite{Existant:Kconfig:frontends} expliquant plus en détail le fonctionnement
pour l'outil \textit{menuconfig}. En reprenant le même mécanisme utilisé par
les outils officiels, nous pourrons éventuellement nous abstenir de refaire le
parsage des nombreux dossiers des sources. Nous avons également récupéré de la
documentation \cite{Existant:Kconfig:vueDensemble}
\cite{Existant:Kconfig:langage} qui contient les éléments de syntaxe qui nous
ont aidés à comprendre comment s'effectue la génération du fichier
\textit{.config}.  De plus, on peut trouver sur le site officiel du noyau Linux
des indications \cite{Existant:Kconfig:modules} permettant de compiler un
module externe au sein du noyau. Celui-ci nous permet donc de mieux comprendre
le fonctionnement des fichiers \textit{Kconfig}.

\section{La bibliothèque python kconfiglib}
\label{sec:La bibliothèque python kconfiglib}

Les fichiers Kconfig sont présents dans toute l'arborescence d'une archive
Linux.  Ces fichiers regroupent toutes les options possibles pour un noyau,
ainsi que les informations correspondantes.  Voici un exemple extrait du
fichier \verb|linux-3.13.6/arch/x86/Kconfig|:
\begin{verbatim}
 config X86_MPPARSE
    bool "Enable MPS table" if ACPI || SFI
    default y
    depends on X86_LOCAL_APIC
    ---help---
      For old smp systems that do not have proper acpi support. Newer systems
      (esp with 64bit cpus) with acpi support, MADT and DSDT will override it
\end{verbatim}
\begin{verbatim}
    un nom : X86_MPPARSE
    un type : bool
    une description / nom long : "Enable MPS table"
    des dépendances : if ACPI || SFI
    une valeur par défaut : default y
    des dépendances : depends on X86_LOCAL_APIC
    une aide : ---help---
        For old smp systems that do not have proper acpi support. Newer systems
        (esp with 64bit cpus) with acpi support, MADT and DSDT will override it
\end{verbatim}

Pour les besoins du projet, il nous était nécessaire de parser les fichiers
Kconfig pour récupérer toutes les informations disponibles sur les options :
nom, description, aide, dépendances... Avant de débuter l'implémentation d'un
parseur, il nous a paru judicieux de vérifier si cet outil n'avait pas déjà été
réalisé par une tierce personne.
Nous avons trouvé sur github \cite{Existant:lib:kconfiglib} la bibliothèque
\textit{Kconfiglib}. Cette bibliothèque est implémentée en Python, ce qui nous
a d'ailleurs poussé vers une implémentation totale dans ce langage, pour être
homogène avec l'API. En effet, celle-ci permet d'extraire facilement toutes les
informations des fichier \textit{Kconfig} dont nous avions besoin, de générer
un fichier \textit{.config}, de lire un fichier \textit{.config} et de modifier
les valeurs des options quand c'est possible (s'il n'y a pas de conflits ou de
problèmes de dépendances).
On peut observer ci-dessous ce que nous avons utilisé dans cette API :
\begin{description}
    \item[La classe Config :] Cette classe permet de parcourir l'archive Linux
        à la recherche de ses fichiers \textit{Kconfig}, afin de les parser et
        de générer en mémoire la structure qui contiendra toutes les options et
        leurs informations (nom, type, valeur, description, aide...).
    \item[La méthode ] \verb|Config.get_top_level_items():| Cette méthode
        retourne une liste \textit{d'items} qui peuvent être des objets des
        classes Symbol, Menu, Choice ou Comment. Chacun d'eux hérite de la
        classe Item.  Dans notre application, nous avons eu à traiter les
        symbols, les choices et les menus.\\

        Un \textit{symbol} est une option basique, de type \textit{bool (oui /
        non)} ou \textit{tristate (oui / non / module)}. La majorité des
        options sont de la classe Symbol.  Un choice est une option de type
        string, dont la valeur est le nom d'une autre option.  Un menu est un
        item qui regroupe des options \textit{symbol et choice} en fonction de
        leurs domaines d'action (exemples : Partition Types, Bus options...).
    \item[La méthode ] \verb|(Symbol||\verb|Choice).get_visibility():| Cette
        fonction permet  de savoir si telle ou telle option est modifiable. Il
        y a plusieurs raisons possibles pour qu'une option ne soit pas
        \textit{visible}:
        \begin{itemize}
            \item Conflit avec une ou plusieurs autres options
            \item Dépendances non satisfaites
            \item Type hexadécimal (hex) / entier (int) \newline
        \end{itemize}
    \item[La méthode ] \verb|Config.write_config():| Cette méthode est appelée
        lorsque la configuration est terminée et / ou qu'il faut sauvegarder le
        fichier. Elle génère le fichier \textit{.config} à l'endroit voulu sur
        le disque. \newline
    \item[La méthode ] \verb|Config.load_config():| Cette méthode nous sert à
        ouvrir un fichier de configuration pour le charger en mémoire, afin
        d'apporter des modifications par exemple.
\end{description}

\section{La bibliothèque pour détecter le matériel}
\label{sec:La bibliothèque pour détecter le matériel}
Afin de pouvoir générer automatiquement un fichier \textit{.config} minimal,
nous avions envisagé de détecter le matériel sur la machine qui exécuterait
notre outil, et de créer une configuration associée en activant les options /
modules correspondants. Comme pour le parsage des \textit{Kconfig}, nous avons
tout d'abord recherché s'il n'existait pas une bibliothèque ou un module
capable de réaliser cette tâche. Nous avons trouvé la bibliothèque
\textit{LKDDb} \cite{Existant:lib:lkddb}. Cette bibliothèque permet de détecter
le matériel, et, couplée à une autre bibliothèque \textit{AutoKernConf}
\cite{Existant:lib:autoKernConf}, de générer un fichier de configuration
minimal. \\

\textit{LKDDb} fournit un script qui permet de générer une liste de
correspondance entre matériel et option. Voici des extraits de cette liste : \\

\begin{verbatim}
lkddb acpi "80860F14" :: CONFIG__UNKNOW__ :: drivers/mmc/host/sdhci-acpi.c
lkddb acpi "80860F28" :: CONFIG_ACPI :: drivers/acpi/acpi_platform.c
[...]
lkddb ap 03 :: CONFIG_ZCRYPT :: drivers/s390/crypto/zcrypt_pcicc.c
lkddb ap 04 :: CONFIG_ZCRYPT :: drivers/s390/crypto/zcrypt_pcica.c
[...]
lkddb ccw 1403 .. .... .. :: CONFIG_S390_VMUR :: drivers/s390/char/vmur.c
lkddb ccw 1731 01 1732 01 :: CONFIG_QETH :: drivers/s390/net/qeth_core_main.c
[...]
lkddb eisa "ABP7501" :: CONFIG_SCSI CONFIG_SCSI_ADVANSYS :: drivers/scsi/advansys.c
lkddb eisa "ADP0000" :: CONFIG_SCSI CONFIG_SCSI_AHA1740 :: drivers/scsi/aha1740.c
\end{verbatim}

C'est \textit{AutoKernConf} qui va détecter le matériel en utilisant des outils
Linux, tels que lspci et cat (sur des fichiers comme \verb|/proc/cpuinfo|, par
exemple), et construire un fichier \textit{.config} avec les bonnes options pour
ce matériel. Tout ça à partir de la liste de correspondance autogénérée par
l'API de \textit{LKDDb}. \\

Nous n'avons pas pu utiliser ce script pour plusieurs raisons :
\begin{itemize}
    \item La dernière version des scripts n'est plus disponible. Nous avons
        seulement pu trouver une ancienne version grâce au site
        \textit{archive.org}.
    \item Les quelques tests que nous avons réalisés montrent que la liste
        d'options générée n'est pas au bon format. En effet, le script faisant
        la correspondance entre les options et le matériel attend un format
        différent.
    \item Nous avons essayé de modifier le formalisme du fichier généré pour
        faire la correspondance ensuite, mais le script récupérant le matériel
        se base sur un noyau Linux 2.* ce qui fait que la liste est incomplète.
\end{itemize}

\chapter{Conception}\thispagestyle{IHA-fancy-style}
\label{cha:Conception}
    \section{Cahier des charges}
    \label{sec:Cahier des charges}
        \subsection{Scénarios et maquettes}
        \label{sub:Scénarios et maquettes}

\subsubsection{Scénario A: Configuration par défaut}
\label{sssub:Scénario A: Configuration par défaut}
\begin{enumerate}
    \item L'utilisateur lance l'application.
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_1_first_dialog.png}
        \centering
        \caption{Maquette 1}
        \label{fig:Maq1}
    \end{figure}
    \item L'utilisateur sélectionne le noyau qu'il souhaite configurer
            (Maquette 1 - Élément A).
    \item L'utilisateur valide le noyau qu'il a choisi (Maquette 1 - Élément C).
    \item L'application charge en mémoire les options du noyau et passe à la
            fenêtre suivante lorsque la barre de chargement est pleine (Passe à
            la Maquette 2).
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_2_choose_dialog.png}
        \centering
        \caption{Maquette 2}
        \label{fig:Maq2}
    \end{figure}
    \item L'utilisateur sélectionne la configuration par défaut (Maquette 2 -
        Élément A).
    \item L’utilisateur clique sur Next (Maquette 2 - Élément F).
    \item L’application sélectionne les options en mémoire pour une
            configuration par défaut. Lorsque la barre de chargement est pleine,
            l’application passe à la fenêtre suivante.
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_3_MainWindowStart.png}
        \centering
        \caption{Maquette 3}
        \label{fig:Maq3}
    \end{figure}
    \item L’utilisateur valide les options pré-sélectionnées en cliquant sur
        Finish (Maquette 3).
    \item L’application génère le fichier “.config”.
    \item L’utilisateur quitte l’application.
\end{enumerate}

\subsubsection{Scénario B: Configuration avancée, modifications, conflits}
\label{sssub:Scénario B: Configuration avancée, modifications, conflits}
\begin{enumerate}
    \item Reprendre le scénario A jusqu’à l’étape 4.
    \item L’utilisateur sélectionne la configuration vierge / empty  (Maquette
        2 - Élément B).
    \item L’utilisateur clique sur Next (Maquette 2 - Élément F).
    \item L’application passe à la fenêtre suivante (Passe à la Maquette 3).
    \item L’utilisateur clique sur “next” et l’application passe sur la
        première option (Passe à la Maquette 4).
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_4_MainWindowSection.png}
        \centering
        \caption{Maquette 4}
        \label{fig:Maq4}
    \end{figure}
    \item L’utilisateur clique sur “next” (Maquette 4), ce qui valide le choix
        précédent (l’option est à “yes” par défaut) et passe à l’option suivante.
    \item L’application précise qu’il y a un conflit (l’option est à “yes” par
        défaut) et n’autorise pas l'utilisateur à cliquer sur “next” (Maquette 5).
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_5_MainWindowSectionConflict.png}
        \centering
        \caption{Maquette 5}
        \label{fig:Maq5}
    \end{figure}
    \item L’utilisateur clique sur “resolve conflict” (Maquette 5).
    \item L’application ouvre une fenêtre de résolution des conflits (Maquette
        6) et affiche toutes les options en conflit.
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_6_resolve_dialog.png}
        \centering
        \caption{Maquette 6}
        \label{fig:Maq6}
    \end{figure}
    \item L’utilisateur clique sur “uncheck all” et valide son choix en cliquant
        sur save (Maquette 6).
    \item L’application applique les changements apportés par l’utilisateur et
        revient à la fenêtre principale (Maquette 4).
    \item L’utilisateur peut dorénavant sélectionner l’option qu’il voulait et
        il clique donc sur “next” (Maquette 4).
    \item L’utilisateur valide les options sélectionnées en cliquant sur Finish
        (Maquette 4).
    \item L’application génère le fichier “.config”.
    \item L’utilisateur quitte l’application.
\end{enumerate}

\subsubsection{Scénario C: Configuration par détection du matériel, recherche d'options}
\label{sssub:Scénario C: Configuration par détection du matériel, recherche d'options}
\begin{enumerate}
    \item Reprendre le scénario A jusqu’à l’étape 4.
    \item L’utilisateur sélectionne la configuration détection du matériel /
        auto hardware (Maquette 2 - Élément C).
    \item L’utilisateur clique sur Next (Maquette 2 - Élément F).
    \item L’application sélectionne les options qui coïncident avec le matériel
        de l’utilisateur. Lorsque la barre de chargement est pleine,
        l’application passe à la fenêtre suivante (Passe à la Maquette 3).
    \item L’utilisateur clique sur Search (Passe à la Maquette 7).
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_7_MainWindowSearch.png}
        \centering
        \caption{Maquette 7}
        \label{fig:Maq7}
    \end{figure}
    \item L’application affiche une zone de saisie.
    \item L’utilisateur saisit un mot clé pour trouver une option.
    \item L’application affiche les options relatives à ce mot-clé (Maquette 8).
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_8_MainWindowSearchResult.png}
        \centering
        \caption{Maquette 8}
        \label{fig:Maq8}
    \end{figure}
    \item L’utilisateur peut sélectionner l’option qu’il voulait.
    \item L’utilisateur valide les options sélectionnées en cliquant sur Finish
        (Maquette 8).
    \item L’application génère le fichier “.config”.
    \item L’utilisateur quitte l’application.
\end{enumerate}

\subsubsection{Scénario D: Configuration par chargement de fichier de configuration, ajout de mots-clés}
\label{ssub:Scénario D: Configuration par chargement de fichier de configuration, ajout de mots-clés}
\begin{enumerate}
    \item Reprendre le scénario A jusqu’à l’étape 4.
    \item L’utilisateur sélectionne la configuration Load .config (Maquette 2 -
        Élément D).
    \item L’application sélectionne les options présentent dans le fichier
        précédemment chargé.
    \item L’utilisateur clique sur Next (Maquette 2 - Élément F).
    \item L’application sélectionne les options présentent dans le fichier
        précédemment chargé. Lorsque la barre de chargement est pleine,
        l’application passe à la fenêtre suivante (Passe à la Maquette 3).
    \item L’utilisateur sélectionne une option et clique sur Keyword (Passe à
        la Maquette 9).
    \begin{figure}[H]
        \includegraphics[scale=0.5]{illustrations/maquettes/Maquette_9_keyword_dialog.png}
        \centering
        \caption{Maquette 9}
        \label{fig:Maq9}
    \end{figure}
    \item L’utilisateur saisit le nom d’un mot-clé et valide l’ajout.
    \item L’utilisateur valide les options sélectionnées en cliquant sur Finish.
    \item L’application génère le fichier “.config”.
    \item L’utilisateur quitte l’application.
\end{enumerate}

        \subsection{Diagramme des cas d'utilisations}
        \label{sub:Diagramme des cas d'utilisations}
\begin{figure}[H]
    \includegraphics[scale=0.25]{illustrations/diagramme_cas_utilisation.png}
    \centering
    \caption{Diagramme des cas d'utilisation}
    \label{fig:DCU}
\end{figure}

\subsection{Besoins fonctionnels et tests prévus}
\label{sub:Besoins fonctionnels et tests prévus}
\subsubsection{Détection du matériel}
\label{ssub:Détection du matériel}
\paragraph{Besoin}
\label{sssbus:Besoin}
Il faut qu’un utilisateur puisse détecter son matériel afin de pouvoir
avoir une liste d’options sélectionnées plus précise/adaptée qu’une
configuration par défaut. Un utilisateur désirant un noyau minimal est
confronté aux soucis qui sont de trouver la correspondance entre son matériel et
les options proposées.
\\

Il existe des outils Linux permettant de récupérer la liste du matériel associé
aux bus PCI et USB de la machine hôte.  N’ayant pas trouvé d’outil Linux
permettant de récupérer directement le ou les modules noyau utilisés sur une
entrée, l’étude du contenu des répertoires \verb|/dev /sys| et \verb|/proc|
sera nécessaire afin d’acquérir de plus amples informations.
\\

Afin de rendre la correspondance des modules du noyau Linux au matériel plus
pertinente et fiable, l’idée serait de récupérer des logs d’exécution du scan
du matériel afin de peupler de manière volontaire une base de données
communautaire.

\paragraph{Test}
\label{sssbus:Test}
Si l’utilisateur précise qu’il réalise une configuration pour la machine
courante, l’application devra l’alerter quand celui-ci cherchera à activer une
option incompatible avec son matériel. Par exemple, si sa machine a un
processeur 32-bits et que l’utilisateur sélectionne l’option pour un processeur
64-bits, l’application devra l’avertir que la configuration ne sera pas adaptée
à sa machine. Des tests similaires pourront être proposés pour de nombreuses
options liées au matériel.


\subsubsection{Gestion des conflits}
\label{ssub:Gestion des conflits}
\paragraph{Besoin}
\label{sssub:BesoinGC}
L’application doit pouvoir “gérer les conflits et les dépendances” entre les
options de configuration. Grâce au fichier kconfig, l’application pourra, pour
chaque option de configuration, connaître ses dépendances et les options avec
lesquelles elle rentre en conflit. De ce fait, chaque fois que l’utilisateur
sélectionne ou désélectionne une option de configuration, des tests sont
effectués par l'application pour savoir si cette option entre en conflit avec
une autre (si elle est cochée) ou génère une erreur de dépendance (si elle est
décochée).

\paragraph{Test}
\label{sssub:TestGC}
La sélection d’une option doit signaler à l’utilisateur l’éventuelle présence
d’un conflit. Il doit également lui être proposé de pouvoir le résoudre. Or,
trouver une solution est un problème NP-complet. En effet, à chaque nouvelle
option il faut vérifier les dépendances de toutes les options précédemment
cochées. Il est possible qu’une option précédente exclût la nouvelle option.
Toutes les options du fichier de configuration en cours d’édition doivent être
vérifiées, ce qui est impossible en un temps polynomial.
\\

Il faudrait vérifier que les conflits présents dans les fichiers Kconfig du
noyau soient bien affichés dans notre outil.

\subsubsection{Recherche}
\label{ssub:Recherche}
\paragraph{Besoin}
\label{sssub:BesoinR}

L’utilisateur doit pouvoir effectuer une recherche sur le nom, la description
et les mots-clés relatifs à une option lors de la configuration du noyau. La
fonction de recherche ne posera pas de véritable problème technique.
L’utilisateur pourra faire défiler les lignes contenant les occurrences du
terme recherché.

\paragraph{Test}
\label{sssub:TestR}
Vérifier que la fonction de recherche retourne bien les résultats attendus. Par
exemple, nous pourrons ouvrir un des outils existants (xconfig, gconfig) et
réaliser une recherche. On effectuera la même recherche sur notre outil et on
pourra vérifier si les résultats sont similaires (ce test ne sera valable que
pour les titres des options).

\subsubsection{Génération et chargement du fichier .config}
\label{ssub:Génération et chargement du fichier .config}
\paragraph{Besoin}
\label{sssub:BesoinConf}
L’utilisateur doit pouvoir sauvegarder où il le souhaite le fichier de
configuration généré par l’application. Un message avertira l’utilisateur de la
présence de conflits ou d’erreurs de dépendance avant que la génération ne soit
faite.
\\

La reprise d’un fichier .config doit permettre à un utilisateur de charger une
configuration existante. Le chargement d’un fichier .config corrompu provoquera
une erreur, et les options inconnues (s’il y en a) seront simplement ignorées.
Cela impliquera le déclenchement du mécanisme de résolution des conflits.

\paragraph{Tests}
\label{sssub:TestsConf}
Vérifier que le fichier de configuration (.config) soit compatible avec
l’application lors de son chargement. Ce dernier doit respecter le format
d’origine, afin que nous puissions récupérer les informations qui nous sont
utiles.
\\

Vérifier que le fichier de configuration que nous générons via notre outil
peut être chargé (toujours via notre outil) et qu’il contienne les mêmes
données. Pour réaliser ce test, on générera à nouveau un fichier de
configuration et on pourra vérifier après ces trois étapes (génération >
chargement > génération) si les informations sont restées les mêmes. Cela
montrera que la génération et le chargement fonctionnent correctement.

\subsubsection{Mots-clés et description d'une option}
\label{ssub:Mots-clés et description d'une option}
Un utilisateur doit pouvoir sélectionner une option et y ajouter un mot-clé.
Par exemple, il peut spécifier qu’une option possède le mot-clé “Network”. Il
pourra également supprimer et modifier les mots-clés existants. De la même
façon, l’utilisateur pourra éditer la description d’une option.

\subsubsection{Plateforme de partage communautaire}
\label{ssub:Plateforme de partage communautaire}
S’il le souhaite, l’utilisateur peut envoyer sur la plateforme de partage, la
correspondance entre le matériel et le module capable de le faire fonctionner,
enrichissant ainsi la base de données de la plateforme.  De la même façon, lors
de la détection du matériel, l’application pourra trouver les modules à activer
(dans le fichier .config) grâce à cette plateforme. Celle-ci servira également
à stocker les “descriptions” et les “mots-clés” des options.

\subsection{Besoins non fonctionnels}
\label{sub:Besoins non fonctionnels}
\subsubsection{Facilité d'utilisation}
\label{ssub:Facilité d'utilisation}
Notre projet consiste à améliorer l’utilisation des fonctionnalités de base des
outils existants, en les rendant plus accessibles. On a pu constater que le
système de recherche des options n’est pas simple à prendre en main et que la
gestion des conflits pouvait être améliorée.
\\

Nous avons décidé d’améliorer la recherche en scrutant au sein des descriptions
des options en plus de leurs noms. De plus, nous affichons les options pouvant
créer des conflits, ainsi que des informations sur leur provenance.

\subsubsection{Profil des utilisateurs}
\label{ssub:Profil des utilisateurs}
Actuellement, les outils de configuration d’un noyau Linux sont “réservés” aux
personnes averties. Il faut donc que les fonctionnalités recherchées soient
présentes. Ces améliorations permettront de toucher un plus large public, de
débutant à expert.

\subsubsection{Portabilité}
\label{ssub:Portabilité}
Il y a deux aspects liés à la portabilité. Dans un premier temps, il est
possible que l’environnement dans lequel l’application sera exécutée ne possède
pas de serveur X (interface graphique). Par conséquent, une solution
privilégiant une interface console (comme Ncurse) serait donc intéressante
puisqu’elle conviendrait à la fois à l’utilisation de l’application sur un
serveur et sur un ordinateur personnel (ou même sur tout type de support
supportant un noyau Linux). Cependant, l’application se voulant être tout
public, une interface lancée depuis la console pourrait se montrer un peu
austère pour un utilisateur habitué à une interface graphique plus
\textit{traditionnelle}.  Dans un second temps, l’application pourra être
fonctionnelle sur un système d’exploitation Windows.

\subsubsection{Contraintes légales}
\label{ssub:Contraintes légales}
Cet outil étant open source, nous avons choisi d’utiliser la licence GPLv3.
Cela permettra la reprise éventuelle de ce projet dans l’avenir.

\subsubsection{Interface web}
\label{ssub:Interface web}
L’utilisateur devrait pouvoir réaliser la détection de son matériel à partir
d’une interface web (comme le site : \textit{ma-config.com}).

\subsection{Priorité des besoins}
\label{sub:Priorité des besoins}
\begin{tabular}{|c|c|}
    \hline
    Besoin & Priorité \\
    \hline
    \hline
    Génération du fichier .config & Haute \\
    \hline
    Gestion des conflits & Haute \\
    \hline
    Chargement d'un fichier .config & Haute \\
    \hline
    Utilisation de l'application sur un bureau & Haute \\
    \hline
    Recherche & Haute \\
    \hline
    Mots-clés et description d'une option & Moyenne \\
    \hline
    Plateforme de partage communautaire & Moyenne \\
    \hline
    Détection du matériel & Moyenne \\
    \hline
    Peuplement de la base pour la détection de matériel & Faible \\
    \hline
    Utilisation de l'application sur un serveur & Faible \\
    \hline
\end{tabular}

\section{Recherches effectuées}
\label{sec:Recherches effectuées}
\subsection{Problème NP-Complet}
\label{sub:Problème NP-Complet}
Au début, nous avions laissé à l'utilisateur la possibilité de résoudre
automatiquement un conflit. Cela nous semblait faisable, mais nous avons
découvert plus tard que pour résoudre les conflits d'une option, il fallait
résoudre tous les conflits des options impliquées dans le premier conflit et
ainsi de suite jusqu'à ce qu'il n'y ait plus de conflit. Nous nous sommes rendu
compte que la hauteur de l'arbre de dépendance de certaines options pouvait
être très grande. Nous avons pris connaissance plus tard que le problème auquel
nous étions confrontés était qualifié de NP-complet. Cependant suite aux
recherches effectuées, nous avons compris le problème.

Soit un ensemble d'options :
\begin{equation}
    (a = true,\; b = true,\; c = false,\; d = false,\; e = true)
\end{equation}
et une règle de satifaisabilité :
\begin{equation}
(a \land b \land c) \lor (\lnot c \land d \land e)
\end{equation}

En connaissant les valeurs de chaque option, on peut tester directement si cette
règle est satisfaite en un temps polynomial.\\
Cependant, c'est un cas idéal et non représentatif de ce que l'on
peut rencontrer réellement. En effet, voici plutôt le type d'ensemble rencontré :

\begin{equation}
(a = true,\; b = e \;\&\&\; !d,\; c = true,\; d = a,\; e = false)
\end{equation}

\begin{figure}[H]
    \includegraphics[scale=1]{./illustrations/np_complet.png}
    \centering
    \caption{Représentation du problème NP-complet}
    \label{fig:NP-complet}
\end{figure}

Ici, les valeurs sont représentées par des conditions d'options. Il faudrait
donc évaluer ces conditions avant de pouvoir résoudre la règle de
satisfaisabilité. Cependant, ces conditions sont-elles même des règles de
satisfaisabilité pour la présence ou non d'une option donnée. \\ Après
recherches, et grâce à nos connaissances du cours de \textit{Modèle de calcul}
du semestre dernier, nous nous sommes rendus compte que nous étions confronté
au problème SAT, prouvé NP-complet.\\

Nous avons décidé d'allouer une partie de notre temps de travail à la recherche
d'une façon de résoudre un problème NP-complet. Lorsque nous avons compris
qu'une solution serait très difficile à trouver, surtout avant l'échéance, nous
avons décidé d'abandonner les recherches et de tenter une approche différente
(détaillée ci-dessous).

\subsubsection{Détection d'une partie des conflits (getlucky)}
\label{ssub:Problème NP-Complet (getlucky)}
Résoudre tous les conflits présents sur toutes les options prendrait trop de
temps.  Nous avons donc tenté une autre approche, où nous tentons de résoudre
le plus de conflits possible avec une certaine limite de profondeur. Si les
conflits ne sont pas résolus lorsque nous atteignons cette limite,
l'application abandonne la résolution, indique à l'utilisateur qu'elle n'a
pas réussi à résoudre les conflits et invite donc l'utilisateur à le faire
lui-même.\\

Exemple :
\begin{verbatim}
Option Z = OptionA && !OptionB
Option A = OptionC && OptionD
Option B = OptionK
Option C = OptionW && OptionX && OptionY
Option D = OptionL && !OptionJ
\end{verbatim}

On part d'un état initial où toutes les options sont à la valeur :
\textit{Non}.  Si l'utilisateur cherche à activer l'option Z, l'option A doit
être à la valeur : \textit{Oui}. La résolution des conflits va tenter de la
placer à \textit{Oui}, mais va échouer, car les conditions de A ne sont pas
respectées. C'est pourquoi elle va tenter de résoudre les conflits de A.
Cependant, elle doit pour cela mettre les valeurs de C et D à \textit{Oui}
seulement si aucun conflit n'est généré en profondeur. L'application descend
donc récursivement dans chacune des options pour tenter de résoudre les
conflits et leur donner la bonne valeur. Mais dans le cas de la détection
partielle des conflits, la résolution ne descendra pas indéfiniment. Dans
l'exemple ci-dessus, nous pouvons imaginer que si elle ne parvient pas à
résoudre les conflits de C et D, elle abandonne et indique à l'utilisateur que
la résolution de conflit a échoué.  \\

Cet algorithme peut sembler assez simple à implémenter, mais il reste encore à
trouver le moyen de déterminer les valeurs des options pour lesquelles la
dépendance est validée. Pour cela nous avons trouvé deux alternatives, la
résolution par \textit{brute-force} et la résolution par \textit{dpll}.


\subsubsection{Résoudre les règles de satisfaisabilitée par brute-force}
\label{ssub:Résoudre les règles de satisfaisabilité par brute-force}
Pour résoudre une règle de satisfaisabilitée, nous avons d'abord tenté
l'approche par brute-force dont le but était de donner à toutes les variables
toutes les valeurs possibles et de sélectionner les combinaisons d'options qui
valident la règle.  \\

Exemple de règle :
\begin{equation}
OptionC\;||\;(OptionA\;\&\&\;!OptionB)
\end{equation}

Pour trouver les valeurs que les options A, B et C doivent prendre, on fait
varier leurs valeurs à l'aide d'une table de vérité.  \\
\newline
\begin{tabular}{|c|c|c||c|}
    \hline
    OptionA & OptionB & OptionC & Résultat\\
    \hline
    \hline
    0 & 0 & 0 & 0\\
    \hline
    0 & 0 & 1 & 0\\
    \hline
    0 & 1 & 0 & 1\\
    \hline
    0 & 1 & 1 & 0\\
    \hline
    1 & 0 & 0 & 1\\
    \hline
    1 & 0 & 1 & 1\\
    \hline
    1 & 1 & 0 & 1\\
    \hline
    1 & 1 & 1 & 1\\
    \hline
\end{tabular}
\newline
\newline

On déduit de ce tableau que les combinaisons suivantes fonctionnent:
\begin{verbatim}
À = Oui et B = ?   et C = ?
À = ?   et B = Oui et C = Non
\end{verbatim}

Si cette approche est assez simple à mettre en place et à comprendre, elle
n'est pas vraiment optimisée. En effet le nombre d'options dans une condition
peut parfois être très élevé. Par exemple \verb|IRQ Domain| contient pas
moins de 40 options.\\
Pour trouver tous les résultats d'une telle règle, il faut une table
de vérité de $1.0995116e^{12}$ lignes ($2^{40}$). Dans cette situation, même
un ordinateur puissant mettra beaucoup de temps à créer cette table.
\\
Voici le temps pour la création d'une table de vérité sur une machine du Cremi :
\\

\begin{tabular}{|c|c|}
    \hline
    Nombre options & temps\\
    \hline
    \hline
    4 & 0.018s\\
    \hline
    8 & 0.020s\\
    \hline
    16 & 0.726s\\
    \hline
    24 & 5m29.844s\\
    \hline
\end{tabular}
\newline
\newline

L'approche par brute-force n'est donc définitivement pas la bonne, même si les
conflits impliquant plus de 20 options ne sont pas nombreux.
Peu de temps après, nous avons tenté de résoudre ce problème avec le DPLL.\\

\subsubsection{Résoudre les équations de conflits par DPLL}
\label{ssub:Résoudre les équations de conflits par DPLL}
Nous avons tenté de résoudre les équations à l'aide de l'algorithme DPLL (qui
semblait pouvoir répondre à notre problématique tout en étant plus optimisé
que le brute-force).\\
Mais, faute de connaissance sur le sujet, nous n'avons pas pu
approfondir davantage cette solution. De ce fait nous avons stoppé toute
recherche sur la résolution de conflits.


\section{Fonction de recherche}
\label{sec:Fonction de recherche}
Les outils de configuration existants ne proposent pas tous la possibilité
d'effectuer une recherche, et donc d'accéder facilement et rapidement à une
option (exemple : \textit{gconf}). D'autant plus que ceux qui le font sont
assez limités puisqu'ils permettent de rechercher dans les noms
(\verb|NOM_D_UNE_OPTION|) des options uniquement (exemple : \textit{qconf}).
Les options ont toutes un nom (\verb|NOM_D_UNE_OPTION|), et la plupart une
description (comprendre un \textit{nom long}, plus explicite que le nom de
l'option) et une aide.  De fait, notre application se propose d'apporter une
amélioration à la recherche en laissant la possibilité à l'utilisateur
d'effectuer sa recherche selon ces trois critères : nom, description et aide.\\

\begin{figure}[H]
    \includegraphics[scale=0.4]{./illustrations/screen_search.png}
    \centering
    \caption{Séléction du mode de recherche sous Windows}
    \label{fig:ModesDeRecherche}
\end{figure}

La recherche par nom rendra la plupart du temps les mêmes résultats que les
outils existants proposant cette fonctionnalité, et parfois plus. En effet,
pour permettre à l'utilisateur de trouver l'option qu'il cherche, même si la
valeur de celle-ci n'est pas modifiable, nos résultats afficheront également
les options sans description, contrairement à \verb|make xconfig|, par
exemple.\\

\begin{figure}[H]
    \includegraphics[scale=0.4]{./illustrations/search_cmp.png}
    \centering
    \caption{Comparaison des modes de recherches}
    \label{fig:ModesDeRecherche}
\end{figure}

On peut constater via ces captures que les résultats sont très différents, et
que la pertinence n'est pas toujours au rendez-vous. En effet, pour une
recherche sur le terme \textit{oss} dans l'aide, correspondant à un module de
son, le nombre important de résultats est dû au fait que ce pattern apparaisse
dans \textit{pOSSible}, par exemple.\\

Il est également possible de coupler ces critères pour rechercher dans le nom
et l'aide en même temps. Les résultats trouvés correspondent aux options dont
le nom ou l'aide associée correspondent au \textit{pattern}. Il s'agit donc d'un
\textit{OU} logique et non pas d'un \textit{ET} logique. Le nombre de résultats
peut être plus important via l'association de plusieurs critères que le plus
grand nombre de résultats pour des critères séparés.\\

\section{Évolutions}
\label{sec:Évolutions}
\subsection{Évolution des besoins}
\label{sub:Évolution des besoins}
Durant la phase de conception de notre projet, nous nous sommes confrontés à
deux difficultés qui ont fait évoluer nos besoins. En effet, nos recherches
n'ont pas permis de résoudre les conflits automatiquement ni de générer une
configuration par défaut en fonction du matériel de l'utilisateur, comme cela a
été évoqué précédemment.  \\

L'objectif de résolution automatique des conflits a été modifié afin de
simplement aider l'utilisateur à trouver les conflits d'une option. Il se
chargera d'en modifier les valeurs par lui-même.  \\

En ce qui concerne le besoin de détecter le matériel d'un utilisateur, celui-ci
s'est transformé pour devenir une base de données communautaire. Celle-ci est
modifiable à l'aide d'un site web. Il est possible d'ajouter des relations
entre des options et des modules, et entre des modules et du matériel. Les
modules représentent la partie \textit{Driver}. Un second besoin, également
ajouté à cette base communautaire, était de pouvoir ajouter des \textit{Tags}
aux options afin de pouvoir les regrouper et d'affiner la recherche.

\subsection{Évolution de l'interface}
\label{sub:Évolution de l'interface}
En parallèle de l'évolution des besoins, l'ergonomie de l'interface a changé
afin d'améliorer l'utilisation de l'application et de correspondre aux
fonctionnalités attendues.

\begin{enumerate}
    \item Évolution de l'interface de configuration de l'application
    \\

    L'interface de configuration permet à l'utilisateur de choisir le noyau et
    l'architecture qu'il désire. Il peut également charger un fichier de
    configuration existant.

    \begin{figure}[H]
        \includegraphics[scale=0.7]{./illustrations/screen_configuration_interface.png}
        \centering
        \caption{Évolution de l'interface de configuration de l'application}
        \label{fig:Evo_config}
    \end{figure}

    L'utilisateur n'a plus que deux choix contre quatre auparavant. En effet,
    il ne peut plus détecter son matériel automatiquement comme cela était le
    cas sur les maquettes. Il ne peut plus créer une configuration vierge, car
    certaines options sont nécessaires pour ne pas créer de conflits.  \\

    \pagebreak
    \item Évolution de l'interface d'affichage des options \\

    L'interface de modification des options autorise l'utilisateur à naviguer
    entre les options avec différents menus. Il peut modifier leurs valeurs
    s'il n'y a pas de conflit et générer un fichier de configuration lorsqu'il
    a terminé.

    \begin{figure}[H]
        \includegraphics[scale=0.5]{./illustrations/screen_options_interface.png}
        \centering
        \caption{Évolution de l'interface d'affichage des options}
        \label{fig:Evo_affichage_opt}
    \end{figure}

    Lorsqu'une option est sélectionnée, il n'y a plus seulement sa description
    d'affichée, mais également ses dépendances. Cela permet à l'utilisateur de
    pouvoir corriger d'éventuels conflits plus facilement.

    \pagebreak

    \item Évolution de l'interface de recherche des options \\

    L'onglet \textit{Search} permet à l'utilisateur d'afficher la liste
    complète des options sous la forme d'un arbre ou une liste plus réduite en
    saisissant un \textit{pattern} à rechercher.

    \begin{figure}[H]
        \includegraphics[scale=0.5]{./illustrations/screen_options_search_interface.png}
        \centering
        \caption{Évolution de l'interface de recherche des options}
        \label{fig:Evo_recherche}
    \end{figure}

    Dans les outils existants ainsi que dans les premiers prototypes, il est
    seulement possible de faire une recherche sur les noms des options.
    Dorénavant, l'utilisateur peut cliquer sur le menu \textit{Search} en haut
    de la fenêtre pour sélectionner ses critères de recherches. Il peut chercher
    dans les noms, les descriptions et les aides des options.

    \pagebreak

    \item Évolution de l'interface d'affichage des conflits \\

    À l'origine, il y avait un bouton sur l'interface permettant d'ouvrir une
    fenêtre pour résoudre les conflits. Il y avait un second bouton relatif à
    l'ajout de \textit{Tags}. Il a également été supprimé, car les tags sont
    uniquement gérés par notre site.

    \begin{figure}[H]
        \includegraphics[scale=0.5]{./illustrations/screen_options_conflits_interface.png}
        \centering
        \caption{Évolution de l'interface d'affichage des conflits}
        \label{fig:Evo_affichage_conflits}
    \end{figure}

    Un nouvel onglet est apparu à droite de la recherche. L'idée de résoudre
    les conflits automatiquement a été remplacée par cet onglet. Il affiche la
    liste des options en conflit avec l'option courante. Cela permet à
    l'utilisateur de se positionner rapidement sur les options qui posent
    problème.
\end{enumerate}

\newpage
\section{Site web}
\label{sec:Site web}
En réponse à l'évolution de nos besoins, nous avons conçu un site sous la forme
d'une base de données communautaires. À l'image du site Wikipédia, les
informations présentes sur ce site sont gérées par les utilisateurs.\\

En effet il est possible de : \\


\begin{itemize}
    \item Ajouter des relations entre un matériel et un module
    \item Ajouter des relations entre une option et un module
    \item Ajouter des relations entre une option et un tag
    \item Supprimer ces relations
    \item Modifier ces relations
    \item Rechercher des relations existantes
\end{itemize}

On peut voir ci-dessous la structure de la base de données du site. \\

\begin{figure}[H]
    \includegraphics[scale=0.2]{./illustrations/diagramme_classes_site.png}
    \centering
    \caption{Diagramme des classes du site}
    \label{fig:DiagSite}
\end{figure}


\chapter{Développement}\thispagestyle{IHA-fancy-style}
\label{cha:Développement}
\section{Choix technologiques}
\label{sec:Choix technologiques}
Dès les premières réunions avec notre client, nous avions discuté du langage à
utiliser pour concevoir l'application. La première proposition était d'utiliser
le langage C. En effet, vu que cette application a pour but d'être adoptée par
la communauté Linux, il aurait été judicieux de la coder avec le langage
système. Dans un premier temps, nous avions pensé à la réaliser en Java, mais
ce langage n'est pas très apprécié par cette communauté.  \\

Ensuite, après avoir bien avancé dans la recherche de notre existant, nous
avons trouvé une bibliothèque en Python permettant de manipuler les options
d'un noyau Linux. Dans une optique d'homogénéité, nous avons décidé de réaliser
toute notre application en Python et cela ne posait aucun problème au client.
\\

En ce qui concerne l'utilisation de la bibliothèque Python que nous avons
trouvée, nous avions le choix entre refaire cette gestion nous-mêmes, ce qui
aurait pris une grande partie de notre temps de développement et celui-ci était
très limité et la garder telle quelle. Nous avons donc décidé de nous servir de
cet existant afin de pouvoir nous concentrer sur d'autres tâches comme
l'affichage des options en conflit.

\section{Architecture}
\label{sec:Architecture}
Nous avons choisi de regrouper chacun de nos modules dans différents fichiers.
Au cours de notre développement, nous sommes passés par plusieurs approches où
nous n'avions pas pris en compte des éléments déjà existants pouvant être
réutilisés. Voici donc le résultat final :
\begin{figure}[H]
    \includegraphics[scale=0.5]{illustrations/archi_add_v1.png}
    \centering
    \caption{Architecture}
    \label{fig:Arch}
\end{figure}

Les liaisons représentent les dépendances entre les différents fichiers.

\subsection{Décomposition modulaire}
\label{sub:Décomposition modulaire}
Notre architecture se base sur le design pattern \textit{MVVM (Model View
ViewModel)} une variante du concept \textit{MVC}. En effet, celui-ci contient
une partie de traitement centralisée dans le module \textit{core} et son
affichage dans le module \textit{render}.

La différence avec le modèle \textit{MVC (Model View Controller)}, c'est qu'il
n'y a pas de contrôleur.  La plupart du temps nous l'utilisons pour contraindre
les actions de l'utilisateur et n'avoir que des événements souhaités. Ce qui ne
nous a pas paru primordial dans notre projet.\\
Notre projet contient trois modules principaux.

\subsubsection{Core}
\label{ssub:Core}
Le module \textit{core} représente le \textit{modèle} de notre architecture.
Celui-ci représente le coeur de notre application et contient ses principales
caractéristiques.
Il est utilisé pour l'initialisation, le parcours et le positionnement de
valeurs d'options d'une configuration Linux à générer. \\
Ce module est lui-même décomposé en un sous-module utilisé comme bibliothèque
interne. Celui-ci contient la bibliothèque \textit{kconfiglib}, base de notre
projet, ainsi que de deux modules \textit{utility} et search nous permettant
d'étendre les fonctionnalités de \textit{kconfiglib}.
\textit{Kconfiglib} nous permet de charger en mémoire une configuration Linux
pour une architecture donnée, modifier et générer un fichier utilisable
dans la compilation d'un noyau.
L'utilisation de \textit{kconfiglib} se fait principalement dans une
arborescence d'un noyau Linux décompressé. Son exécution se fait à partir d'une
cible de compilation afin de récupérer les variables d'environnement
initialisées dans le Makefile principal du noyau Linux. \\
Le module utility permet de faire \textit{croire} à la bibliothèque kconfiglib
que son exécution se fait bien dans à partir de cette cible en initialisant les
variables d'environnement propres à son Makefile, par exemple
l'architecture choisie. \\
Afin de récupérer les différentes conditions \textit{(prompt, default, select,
reverse, additionnal)} pour des pistes de résolutions de conflits, une idée
était de parser le retour de la fonction \verb|__str__()| de chacun des
\textit{symboles}.
Cependant, \textit{kconfiglib} avait déjà récupéré ces valeurs et les a mis en
attribut des \textit{symboles} dans un format préfixe, sauf pour les
dépendances additionnelles.\\
Exemple pour l'option \verb|CONNECTOR|:
\[\verb|[&&, [DM_MIRROR, NET, MD, DM_LOG_USERSPACE]|\\\]
Sous cette forme, il est facile de créer un arbre qu'on puisse parcourir en
profondeur. On peut ainsi avoir la notation infixe représentative.  Chacun
des noeuds aurait comme valeur soit un arbre, soit un opérateur logique (||
\&\& !) et au niveau des feuilles le nom d'un symbole.\\

\begin{figure}[H]
    \includegraphics[scale=0.5]{illustrations/condition_tree.png}
    \centering
    \caption{Exemple d'une représentation en arbre d'une condition}
    \label{fig:condTree}
\end{figure}

Le module search, permet de chercher une liste d'options ayant au choix, dans
leur nom, leur description et leur aide, un mot-clé mis en entrée.

\subsubsection{Render}
\label{ssub:Render}
Le module render représente la \textit{vue} de notre architecture.  Celui-ci
représente l'interface visuelle du module \textit{core}.  Dans la version
délivrée, il contient une implémentation \textit{GTK} sous la forme de classes
utilisant des fichiers XML générés avec l'outil \textit{Glade} correspondant à
nos maquettes.

\subsubsection{Sync}
\label{ssub:Sync}
L'architecture choisie rend l'application maintenable, modulaire et
indépendante du choix de l'implémentation de l'IHM. En effet, la partie
graphique ne fait qu'afficher l'état courant dû \textit{modèle} et le module
\textit{sync} permet aux bibliothèques graphiques de mettre à jour un objet,
tel qu'une barre de chargement. Ce mécanisme nous permet d'afficher
l'avancement de l'initialisation du logiciel pour l'utilisateur final.  \\

De plus, le logiciel étant ouvert, on laisse à ceux qui le veulent le choix de
modifier ou de changer le comportement proposé, mais aussi d'outil graphique.
En effet, il est possible de migrer vers une autre solution telle que QT, pour
un choix de portabilité avancé,  ou encore \textit{ncurses}, ce qui répondrait
à un de nos besoins non fonctionnel, qui était de pouvoir lancer l'application
en mode console sur un environnement avec ou sans serveur X.  Une ébauche d'une
interface console est présente dans l'application \textit{lkc\_prompt.py}. \\

\section{Cycle de vie}
\label{sec:Cycle de vie}
\begin{figure}[H]
    \includegraphics[scale=0.7]{./illustrations/cycle_cascade.png}
    \centering
    \caption{Schéma du cycle de vie en cascade avec retours}
    \label{fig:CycleCascade}
\end{figure}

Ce projet a eu un cycle de vie en cascade avec retours. En effet, durant toutes
les phases de notre projet, nous avons soumis notre travail à vérification et
validation afin de pouvoir être en accord avec notre chargé de TD et notre
client. L'utilisation de ce cycle de développement n'a pas été un choix, car il
était imposé par le formalisme de cet enseignement. Cependant, celui-ci a été
très utile, car il nous a permis de réaliser une analyse conséquente dès le
début du projet afin de définir précisément les besoins de notre client.

\chapter{Tests effectués}\thispagestyle{IHA-fancy-style}
\label{cha:Tests}
\section{Tests fonctionnels}
\label{sec:Tests fonctionnels}
\subsection{Tests unitaires}
\label{sub:Tests unitaires}
Pour les tests unitaires, nous utilisons une API Python spécialisée dans les
tests (\textit{unittest}). Toutes les fonctions dans la classe commençant par
le mot \textit{test} sont exécutées une par une.\\ Un message précisant si le
test est valide ou non, est affiché dans la console.\\

Pour essayer de rendre les tests homogènes, nous avons décidé de créer trois
variables contenant les données nécessaires pour les tests :
\begin{itemize}
    \item Les paramètres passés à la fonction testée
    \item Le résultat attendu après le calcul de la fonction
    \item Le résultat après le calcul de la fonction
\end{itemize}

Une grande partie des fonctionnalités développées dans ce projet utilisent des
fonctions dont l'usage est générique (elles peuvent être utilisées dans plein
de cas différents et ne sont pas développées juste pour une fonctionnalité). Il
est donc capital d'effectuer des tests sur ces fonctions pour tenter de
découvrir des comportements erronés ou inattendus.

Ces fonctions génériques sont dans le fichier
\verb|application/core/utility.py|.

\subsubsection{\texttt{test\_convert\_list\_xDim\_to\_1Dim}}
\label{ssub:ConvertListXDIMto1DIM}
La fonction \verb|convert_list_xDim_to_1Dim| sert à convertir une liste à
plusieurs dimensions en une liste d'une seule dimension.
\\
Exemple:
\begin{verbatim}
[[1,2], [3], [4, [5, 6]]] → [1, 2, 3, 4, 5, 6]
\end{verbatim}

Nous avons donc essayé de mettre en entrée des listes de tests complexes ou
inhabituels, comme :
\begin{itemize}
    \item Une liste d’une dimension
    \item Une liste contenant des listes d'une grande profondeur
    \item Une liste contenant des listes vides
    \item Un autre objet qu'une liste
\end{itemize}

\subsubsection{\texttt{test\_convert\_tuple\_to\_list}}
\label{ssub:ConvertTupleToList}
Cette fonction sert à convertir un tuple en liste. Elle est utile, car peu
d'opérations (intéressante pour nous) peuvent être effectuées sur les tuples,
tout le contraire des listes. Il nous est donc plus aisé de travailler avec des
listes, mais le plus souvent \textit{kconfiglib} nous fournis des tuples.
\\
Exemple:
\begin{verbatim}
((1,2), (3), (4, (5, 6))) → [[1, 2], [3], [4, [5, 6]]]
\end{verbatim}

Les tests sont assez similaires à ceux de
\verb|test_convert_list_xDim_to_1Dim|. \\

\subsubsection{\texttt{test\_get\_symbols\_list}}
\label{ssub:TestGetSymbolsList}
Cette fonction permet de transformer un arbre représentant une condition en une
liste donnant le nom des \textit{symboles (options)} présents dans cette
condition. Le principe derrière ce test est de vérifier qu'on récupère
uniquement les options. Les autres objets de la condition (comme des opérateurs
booléens) ne sont pas pertinents pour ce traitement.\\ Il est à noter que la
fonction est susceptible de retourner une liste dont certains éléments seraient
des éléments booléens \textit{(Yes, No)} ou tristate \textit{(Yes, No,
Module)}.  Mais un traitement ultérieur (hors de la fonction) est fait pour
épurer le résultat.\\

Cette fois le but du test est de tester la fonction avec des conditions
complexes. Il est important de préciser qu'une grande majorité des cas d'erreur
est directement géré dans la fonction elle-même.\\

Le test de cette fonction à l'avantage de tester une nouvelle fois la fonction
\verb|convert_list_xDim_to_1Dim|.

\subsubsection{\texttt{test\_get\_first\_option\_menu}}
\label{ssub:TestGetFirstOptionMenu}
Ce test vérifie que la première option d'un menu est définie par un indice
supérieur à -2 et inférieur que le nombre total d'option.

\subsubsection{\texttt{test\_get\_index\_menu\_option}}
\label{ssub:TestGetIndexMenuOption}
Dans l'onglet section de notre application, nous affichons une liste des menus
se trouvant en haut de l'arborescence. C'est-à-dire que nous n'affichons aucun
menus qui sont dans des menus. Lorsque l'utilisateur navigue dans les options,
nous mettons en surbrillance le menu dans lequel se trouve l'option.  Ce test
permet de vérifier la plage des valeurs de retour de la fonction.  Si la
fonction renvoie 0 c'est que l'option ne se trouve pas dans un menu sinon elle
retourne l'indice du menu où se trouve l'option. Cet indice atteint au
maximum le nombre de menus de haut niveau.

\subsubsection{\texttt{test\_get\_all\_items}}
\label{ssub:TestGetAllItems}
Cette fonction permet de convertir le résultat d'une autre fonction
\verb|get_top_level_items()| qui retourne la liste des items de haut niveau.
C'est-à-dire que cette fonction parcourt l'ensemble des options en mémoire et
lorsqu'elle tombe sur un \textit{menu} par exemple, elle le retourne plutôt que
de retourner les options qui sont à l'intérieur. La fonction
\verb|get_all_items()| permets de récupérer uniquement les options et les choix
en parcourant en profondeur tous les items. Les menus et les commentaires sont
enlevés par cette fonction. Ce test vérifie qu'il ne reste plus que des
\textit{symbols} et des \textit{choice} dans la liste retournée.

\begin{verbatim}
test_convert_list_xDim_to_1Dim (__main__.UnitTest) ... ok
test_convert_tuple_to_list (__main__.UnitTest)
Converts a tuple in a list ... ok
test_get_all_items (__main__.UnitTest) ... ok
test_get_first_option_menu (__main__.UnitTest) ... ok
test_get_index_menu_option (__main__.UnitTest) ... ok
test_get_symbols_list (__main__.UnitTest) ... ok

----------------------------------------------------------------------
Ran 6 tests in 0.229s

OK
\end{verbatim}


\subsubsection{Test parcours de la liste des options}
\label{ssub:Test parcours de la liste des options}

Nous avons réalisé un test fonctionnel \textit{manuel}, afin de vérifier si
chacune des options est accessible sans provoquer d'erreurs. En effet, il y
a deux façons de parcourir l'ensemble des options d'un noyau.
La première est d'appuyer sur le bouton \textit{next} et la seconde est de
faire défiler la liste arborescente des options dans l'onglet recherche.
Nous avons appuyé de façon continue sur les touches afin d'effectuer ces deux
procédures.\\
Avec ce test, nous avons pu détecter des erreurs, notamment sur certaines
\textit{options} ou même sur certaines architectures non communes.

\section{Tests non fonctionnels}
\label{sec:Tests non fonctionnels}
\subsection{Fuite de mémoire}
\label{sub:Fuite de mémoire}
Nous avons utilisé un outil \textit{(smem)}, couplé à un script, pour consulter
la mémoire utilisée par notre application à n'importe quel moment. Nous avons
donc tenté de suivre l'évolution de la mémoire après certaines actions
supposées fréquentes de l'utilisateur :

\begin{description}
    \item[La sauvegarde d'une configuration :] Nous avons remarqué que
        plusieurs sauvegardes à la suite entrainent une consommation (non
        excessive) de la mémoire, mais elle semble redescendre peu de temps
        après au niveau initial.
    \item[Le défilement des options et la recherche:] Ils n'entrainent aucune
        fuite mémoire.
\end{description}

\subsection{Tests de portabilité}
\label{sub:Tests de portabilité}

Une des demandes du client était que notre application réponde à la contrainte
de la portabilité. Étant donné que nous avons utilisé \textit{Python} notre
application allait être exécutable sur les trois plateformes et des tests à la
fin de notre projet nous l'ont prouvé.\\
Il est possible que la dernière version de \textit{MacOSX Maverick} ne permette
pas le bon fonctionnement du \textit{binding Python} de la bibliothèque
\textit{GTK3}. Donc la seule partie de notre application à ne pas être
entièrement portable est son interface graphique.\\

Note : Pour l'utilisation de notre application sous \textit{Windows}, il a fallu
modifier très légèrement l'API \textit{kconfiglib}. En effet, celle-ci
utilisait la fonction \verb|os.uname()| qui n'est présente que dans les
systèmes \textit{UNIX}, par conséquent, nous avons commenté cette ligne dans le
code, puisque nous n'utilisons jamais cette fonctionnalité.

\subsection{Vitesse au chargement}
\label{sub:Vitesse au chargement}

La rapidité de l'application n'était pas un besoin énoncé par notre client,
mais nous avons tout de même voulu voir la comparaison des vitesses au
chargement du noyau entre elle et les outils existants.\\

Nous avons fait cinq tests pour chaque application (les tests ont été réalisés
sur des machines différentes):

\begin{tabular}{|c|c|}
\hline
test LKC & temps (en sec) \\
\hline
\hline
1 & 11.56 \\
\hline
2 & 13.67 \\
\hline
3 & 9.13 \\
\hline
4 & 10.56 \\
\hline
5 & 12.80 \\
\hline
\end{tabular}
\newline
\newline

\begin{tabular}{|c|c|}
\hline
test XCONFIG & temps (en sec) \\
\hline
\hline
1 & 18.42 \\
\hline
2 & 15.03 \\
\hline
3 & 18.94 \\
\hline
4 & 12.23 \\
\hline
5 & 21.10 \\
\hline
\end{tabular}
\newline
\newline

\begin{tabular}{|c|c|}
\hline
test GCONFIG & temps (en sec) \\
\hline
\hline
1 & 9.77 \\
\hline
2 & 9.31 \\
\hline
3 & 7.18 \\
\hline
4 & 11.42 \\
\hline
5 & 8.78 \\
\hline
\end{tabular}
\newline
\newline

Le graphique suivant synthétise les résultats, les trois applications ont été
testées sur cinq machines différentes.

\begin{figure}[H]
    \includegraphics[scale=0.4]{./illustrations/speed_cmp.jpeg}
    \centering
    \caption{Comparaison des vitesses de chargement des noyaux}
    \label{fig:VitesseChargement}
\end{figure}
Nous pouvons observer sur ce schéma, trois courbes représentant la vitesse
de chargement d'un noyau sur trois outils, dont deux existants.
On constate que notre outil \textit{LKC} et \textit{gconfig} se chargent en un
temps équivalent, alors que \textit{xconfig} est significativement plus lent.
Nous considérons que notre application à un temps de chargement raisonnable
en comparaison des outils existants. Le premier chargement du noyau (représenté
par ces statistiques) est toujours le plus long sur notre application. Les
chargements suivants prennent en moyenne deux fois moins de temps.

\chapter{Résultats}\thispagestyle{IHA-fancy-style}
\label{cha:Résultats}
\section{Ce qui a été fait}
\label{sec:Ce qui a été fait}

Notre application permet de sélectionner un noyau Linux pour générer son
fichier de configuration nécessaire à la compilation. A tout moment
l'utilisateur peut rechercher une option dans la liste des options chargées. Il
est possible d'afficher la liste des options sous forme d'arborescence pour
améliorer la lisibilité et l'accessibilité aux options. Des fichiers .config
peuvent être générés par l'utilisateur lorsque celui-ci le désire.
Ultérieurement, il pourra charger ce fichier \textit{.config} dans
l'application et retrouver l'état des options tel qu'il les avait laissés après
enregistrement.\\

Par rapport aux outils existants, il est possible de visualiser les options qui
ne sont pas modifiables, et ainsi savoir pourquoi elles ne le sont pas.  Il est
de plus possible d'accéder aux options posant problème afin d'essayer de
satisfaire les multiples conditions présentes pour une option donnée.\\

Nous avons développé un site communautaire pour l'obtention d'information sur
le matériel compatible avec des options associées à un noyau Linux. Ce site
permet également de catégoriser des options à partir de mots-clés.

\section{Ce qui reste à faire}
\label{sec:Ce qui reste à faire}
Il faudrait mieux catégoriser les sections pour des utilisateurs non experts.
En effet, actuellement, on récupère les menus racines des fichiers
\textit{Kconfig}, alors que nous pourrions créer nos propres groupes d'options,
ce qui pourrait être plus précis et plus pertinent. Cependant, ce tri peut être
sujet à l'erreur par manque d'information et peut aussi être difficile à
réaliser.\\

Étant bloqué dans le choix du langage de programmation avec la bibliothèque
utilisée, \textit{kconfiglib}, on pourrait éventuellement réfléchir à une
alternative pour un chargement plus rapide en mémoire d'une configuration
Linux.\\

L'API \textit{kconfiglib} pourrait par exemple être réécrite en C, avec
\textit{Bison} et \textit{Lex} comme parser de fichier \textit{Kconfig}.

À court terme, la fonctionnalité la plus importante à ajouter à notre
application serait de créer une correspondance entre la base de données du site
communautaire et l'application. Grâce à ça, il serait possible de faire des
recherches d'options par rapport à un nom de matériel, au sein même de la
recherche. On pourrait également rechercher des options en fonction des tags
que la communauté aura créés. Au fil du temps, les données du site s'affineront
pour être de plus en plus précises. On peut également imaginer que d'autres
informations seront modifiables à partir du site, par exemple, la
description des options.\\

On pourrait avoir une réelle gestion du site communautaire, en vérifiant les
entrées. De plus, permettre à l'utilisateur de visualiser s'il le souhaite, les
options qui ne sont pas modifiables telles que \textit{STRING/HEX/INT} serait
une information utile. Il serait également possible de pousser encore plus
loin l'aspect portabilité. En effet, on pourrait laisser la possibilité de
configurer un noyau Linux sur le site.\\

Afin d'aider l'utilisateur final dans sa résolution de conflits, on peut
envisager une résolution automatique des conflits de manière sommaire
\textit{Get lucky}.

\chapter{Conclusion et bilan}\thispagestyle{IHA-fancy-style}
\label{cha:Conclusion et bilan}
Afin de répondre au besoin de portabilité de l'application en mode console,
on pourrait faire évoluer le prototype présent \textit{lkc\_prompt.py}.
Ce projet de programmation a été l'aboutissement de notre première année de
Master Informatique à l'université de Bordeaux. Celui-ci nous a apporté
beaucoup en ce qui concerne l'expérience de la réalisation d'un projet
informatique dans son ensemble et il a également été bénéfique au niveau
technique et relationnel.\\

Dans un premier temps, au niveau technique, ce projet nous a permis
d'approfondir nos compétences dans certains langages que nous avions
précédemment utilisés comme le Python, mais aussi d'en apprendre de nouveaux
comme \textit{GTK} pour réaliser la partie graphique. Nous avons ainsi élargi
nos connaissances informatiques. Nous avons dû nous familiariser avec la
bibliothèque \textit{Kconfiglig} pour interagir avec les options d'un noyau
Linux. De même, nous avons pu constater l'importance de l'analyse et conception
dans un projet concret, en nous permettant de fixer les bases du projet afin
d'avoir des documents sur lesquels s'appuyer. Ils seront d'autant plus utiles
aux personnes qui voudraient reprendre notre projet à l'avenir.\\

Dans un second temps, concernant l'aspect relationnel, nous avons beaucoup
appris, qu'il s'agisse de la communication interne au groupe, ou de la
communication avec l'extérieur. Il a été nécessaire de comprendre et de
détailler les différents besoins de nos commanditaires. Cette étape nous a pris
beaucoup de temps, mais nous a permis d'avoir des documents d'analyse détaillés
pour réaliser la partie technique de manière plus fluide et efficace. Ensuite,
nous avons pu travailler en groupe sur tout un semestre. Nous avons pu ainsi
nous rendre compte qu'il n'est pas toujours évident de gérer une équipe avec
les tensions qui peuvent apparaître. Mais nous avons réussi à réaliser ce
travail en répartissant les tâches à accomplir et en nous réunissant
fréquemment pour tenir compte des problèmes rencontrés.\\

\bibliographystyle{unsrt}
\nocite{*}
\bibliography{./bibliographie}

\chapter{Annexes}\thispagestyle{IHA-fancy-style}
\label{cha:Annexes}
\section{Documentation / manuel}
\label{sec:Documentation / manuel}

\newpage
\includepdf[pages=-, scale=0.9]{./illustrations/core_appcore.pdf}
\includepdf[pages=-, scale=0.9]{./illustrations/core_test.pdf}
\includepdf[pages=-, scale=0.9]{./illustrations/render_configurationInterface.pdf}
\includepdf[pages=-, scale=0.9]{./illustrations/render_optionInterface.pdf}

\end{document}
